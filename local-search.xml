<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>分组密码AES和DES</title>
    <link href="/2021/09/12/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81AES%E5%92%8CDES/"/>
    <url>/2021/09/12/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81AES%E5%92%8CDES/</url>
    
    <content type="html"><![CDATA[<h1 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h1><p>DES是一种典型的Feistel结构密码体制，它使用长度为56比特的密钥加密（解密）长度为64比特的明文（密文），获得长度为64比特的密文（明文）。其加密流程如下：</p><p>1.传入64比特的明文，进行IP置换</p><p>2.通过密钥扩展算法获得轮密钥，扩展算法为：将初始密钥进行PC-1置换后得到$C_0,D_0$两部分，再进行本轮的循环移位后进入PC-2置换（从56比特选取48比特）得到轮密钥。下一轮的轮密钥和上一轮的轮密钥关系为：</p><script type="math/tex; mode=display">C_i=C_{i-1}<<<<r_i</script><script type="math/tex; mode=display">D_i=D_{i-1}<<<<r_i</script><script type="math/tex; mode=display">K_i=PC-2(C_iD_i)</script><p>3.初始置换后的明文分为左右两部分，进入轮密钥控制的16次F函数（轮函数）迭代（Feistel结构），前十五次的迭代方式为：$L<em>i=R</em>{i-1}，R<em>i=L</em>{i-1}+F(R_{i-1},K_i)$，最后一次的迭代方式稍稍不一样，为：</p><script type="math/tex; mode=display">L_{16}=L_{15}+F(R_{15},K_{16}),R_{16}=R_{15}</script><p>这里的”+”代表异或，最后一次不同的原因是为了保证加解密的一致性——若加密采用的轮密钥为$(K<em>1,K_2,…,K</em>{16})$，则解密采用轮密钥为$(K<em>{16},K</em>{15},…,K_1)$，并且加解密流程采用完全相同的结构和轮函数</p><p>4.进行初始逆置换$IP^{-1}$，得到密文</p><h2 id="核心轮函数F"><a href="#核心轮函数F" class="headerlink" title="核心轮函数F"></a>核心轮函数F</h2><p>1.将输入的32比特通过扩展函数E变为48比特</p><p>2.将得到的48比特与子密钥异或后进入S盒，作为S盒的输入</p><p>3.S盒是一个非线性变换，它将输入通过8个并置的6进4出（比特位）的S盒压缩成32比特。每个S盒都有一张替换表，替换表都有4行16列，对应前十六个整数（长度为4的比特串）的二进制整数全排列。设S盒的输入为$a_1a_2a_3a_4a_5a_6$，则$S(a_1a_2a_3a_4a_5a_6)$就是S盒表中第$a_1a_6$行和第$a_2a_3a_4a_5$列交叉的那个数，这里的$a_1a_6 $和$a_2a_3a_4a_5 $都是二进制整数</p><p>4.将S盒得到的32位比特输出作为输入进行P置换，P置换的结果就是轮函数的输出</p><h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>AES即美国国家高级加密标准（$Advanced\ Encryption\ Standard$），其算法为$Rijndael$算法，分组长度通常为128比特，密钥长度通常也为128比特，加密轮数为10轮</p><h2 id="加密步骤"><a href="#加密步骤" class="headerlink" title="加密步骤"></a>加密步骤</h2><p>首先将输入的明文分组为16个字节$a<em>{00}a</em>{10}a<em>{20}a</em>{30}a<em>{01}a</em>{11}a<em>{21}a</em>{31}a<em>{02}a</em>{12}a<em>{22}a</em>{32}a<em>{03}a</em>{13}a<em>{23}a</em>{33}$，并+按照顺序映射为状态字节矩阵，加密操作结束时，密文按同样顺序从状态抽取，映射顺序为：</p><script type="math/tex; mode=display">\begin{pmatrix}a_{00}&a_{01}&a_{02}&a_{03}\\a_{10}&a_{11}&a_{12}&a_{13}\\a_{20}&a_{21}&a_{22}&a_{23}\\a_{30}&a_{31}&a_{32}&a_{33}\\\end{pmatrix}</script><p>1.由密钥拓展算法将128比特的种子密钥拓展成11个128比特的轮密钥，每一个轮密钥同样被表示成与明文状态矩阵大小相同的矩阵</p><p>2.进行初始白化：将明文状态矩阵与第0轮的轮密钥进行加法运算</p><p>3.进行完全相同的9轮变换，每一轮变换都是以上一轮的输出作为输入，依次执行字节替换、行移位、列混合和轮密钥加四种运算</p><p>4.最后一轮的迭代变换稍有不同，这一轮变换依次执行字节替换、行移位和轮密钥加，没有列混合</p><p>5.将最后一轮输出的结果按照顺序从状态中抽取出来就是密文</p><h3 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h3><p>状态矩阵每一行按照不同的移位值进行循环左移</p><h3 id="列混合（列混淆）"><a href="#列混合（列混淆）" class="headerlink" title="列混合（列混淆）"></a>列混合（列混淆）</h3><p>将状态矩阵每一列看作$GF(2^8)$域上的次数不超过3的多项式，与下列矩阵作乘法运算</p><script type="math/tex; mode=display">\begin{pmatrix}02&03&01&01\\01&02&03&01\\01&01&02&03\\03&01&01&02\\\end{pmatrix}</script><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>此处的加法应理解为域上的加法运算（与异或等价）</p><h3 id="密钥扩展方案"><a href="#密钥扩展方案" class="headerlink" title="密钥扩展方案"></a>密钥扩展方案</h3><p>待补充</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Crypto</category>
      
      <category>理论学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>密码系统</title>
    <link href="/2021/09/08/%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/09/08/%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Diffie-Hellman"><a href="#Diffie-Hellman" class="headerlink" title="Diffie-Hellman"></a>Diffie-Hellman</h1><p>Diffie-Hellman密钥交换。</p><p>基于离散对数困难问题。</p><h1 id="ElGamal"><a href="#ElGamal" class="headerlink" title="ElGamal"></a>ElGamal</h1><p>基于离散对数问题。</p><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>1.选取足够大的素数p保证p-1存在很大的素因子，使得在$Z_p$上求解离散对数问题是困难的</p><p>2.选取$Z_p ^*$的生成元g</p><p>3.随机选取整数k满足$0≤k≤p-2$，并计算$g^k\equiv y\ (mod\ p)$</p><p>公钥为{$p,g,y$}，私钥为{$k$}。</p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>选取一个随机整数$r\in Z_{p-1}$，得到密文$(y_1,y_2)=(g^rmod\ p,my^rmod\ p)$，其中m为要发送的消息（明文）。</p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>解密时，通过私钥k计算$(y_1^k)^{-1}y_2mod\ p=(g^{rk})^{-1}my^rmod\ p=m$.</p><p>参考CTF WIKI</p><h1 id="Paillier-Cryptosystem"><a href="#Paillier-Cryptosystem" class="headerlink" title="Paillier Cryptosystem"></a>Paillier Cryptosystem</h1><h2 id="密钥生成-1"><a href="#密钥生成-1" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>一般过程：</p><p>1.随机选择两个大素数p,q满足$gcd(pq,(p-1)(q-1))=1$，当p,q长度相同时一定有该结论</p><p>2.计算$n=pq，\lambda=lcm(p-1,q-1)=(p-1)(q-1)/gcd(p-1,q-1)$</p><p>3.随机选取整数$g,0&lt;g&lt;n^2$</p><p>4.$L(x)=(x-1)/n$</p><p>5.计算$\mu=(L(g^\lambda(mod\ n^2)))^{-1}\ (mod\ n)$</p><p>6.公钥为（n，g），私钥为（$\lambda，\mu$）</p><p>特殊情况：</p><p>通常，为简便，我们参数选取如下：</p><p>1.$g=n+1$</p><p>2.$\lambda=\varphi(n)$</p><p>3.$\mu=\varphi(n)^{-1}\ (mod\ n)$</p><h2 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h2><p>1.m为要发送的消息（明文），满足$0≤m&lt;n$</p><p>2.随机选取r，使得$gcd(r,n)=1$</p><p>3.密文$c:c=g^m\cdot r^n\ (mod\ n)$</p><h2 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h2><p>$m=(L(c^\lambda\ (mod\ n^2))\cdot\mu)\ (mod\ n)$</p><h1 id="同态性质"><a href="#同态性质" class="headerlink" title="同态性质"></a>同态性质</h1><p>$D(E(m_1,r_1)\cdot E(m_2,r_2))\ (mod\ n^2)=m_1+m2\ (mod\ n$)</p><p>$D(E(m,r)^k\ mod\ n^2)=km\ mod\ n$</p><h1 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h1><ul><li><p>同态性质攻击</p></li><li><p>选择明文攻击</p><p>参考：<a href="http://coinc1dens.me/2021/07/01/Some_other_cryptosystem.html">一些密码系统 - Coinc1dens’ Diary</a></p></li></ul><h1 id="DSA-System"><a href="#DSA-System" class="headerlink" title="DSA System"></a>DSA System</h1><p>与前面的不同，DSA算法是一种数字签名算法，一般不用于加解密</p><h2 id="密钥生成-2"><a href="#密钥生成-2" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>1.选择合适的哈希函数，一般选择SHA-1</p><p>2.选择密钥的长度L和N，这两个值决定了签名的安全程度。一般来说L为64的倍数，且$512≤L≤1024$，N必须不大于哈希函数H输出的长度</p><p>3.选择N比特的素数q</p><p>4.选择L比特的素数p，使得$q|p-1$</p><p>5.选择满足$g^k\equiv1\ mod\ p$的最小正整数k为q的g（即g的阶为q）。在这里，我们可以通过计算$g\equiv h^{p-1\over q}\ mod\ p$来得到g，其中$1&lt;h&lt;p-1$.</p><p>6.选择私钥x，$0&lt;x&lt;q$，计算$y\equiv g^x\ mod\ p$</p><p>公钥为（p,q,g,y)，私钥为(x).</p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>签名步骤：</p><p>1.选择随机整数k作为临时密钥,$0&lt;k&lt;q$</p><p>2.计算$r\equiv(g^k\ mod\ p)\ mod\ q$</p><p>3.计算$s\equiv(H(m)+xr)k^{-1}\ mod\ q$</p><p>签名结果为（r，s）</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证步骤：</p><p>1.计算辅助量，$w\equiv s^{-1}\ mod\ q$</p><p>2.计算辅助量，$u_1\equiv H(m)w\ mod\ q$</p><p>3.计算辅助量，$u_2\equiv rw\ mod\ q$</p><p>4.计算$v\equiv (g^{u_1}y^{u_2}\ mod\ p)\ mod\ q$</p><p>5.如果有$v=r$，则验证成功</p><h2 id="攻击方法-1"><a href="#攻击方法-1" class="headerlink" title="攻击方法"></a>攻击方法</h2><h3 id="k泄露"><a href="#k泄露" class="headerlink" title="k泄露"></a>k泄露</h3><p>如果我们知道了k，那么我们可以获取私钥为：</p><script type="math/tex; mode=display">x\equiv r^{-1}(ks-H(m))\ mod\ q</script><h3 id="k共享"><a href="#k共享" class="headerlink" title="k共享"></a>k共享</h3><p>如果在两次签名过程使用了同一个k，这时我们可以攻击。</p><p>假设签名的消息为$m_1,m_2$，显然，两者的r值相同，我们还有：</p><script type="math/tex; mode=display">s_1\equiv (H(m_1)+xr)k^{-1}\ mod\ q</script><script type="math/tex; mode=display">s_2\equiv (H(m_2)+xr)k^{-1}\ mod\ q</script><p>化为：</p><script type="math/tex; mode=display">s_1k\equiv H(m_1)+xr</script><script type="math/tex; mode=display">s_2k\equiv H(m_2)+xr</script><p>两式相减</p><script type="math/tex; mode=display">k(s_1-s_2)\equiv H(m_1)-H(m_2)\ mod\ q</script><p>此时我们可以解出k，进一步可以解出x</p><h3 id="进阶攻击方法"><a href="#进阶攻击方法" class="headerlink" title="进阶攻击方法"></a>进阶攻击方法</h3><p>MSB泄露攻击（HNP问题的方法），借助格和LLL算法，待补充</p><h1 id="Shamir’s-Secret-Sharing-Algorithm"><a href="#Shamir’s-Secret-Sharing-Algorithm" class="headerlink" title="Shamir’s Secret Sharing Algorithm"></a>Shamir’s Secret Sharing Algorithm</h1><p>基于拉格朗日插值法（也可理解为方程组的秩）</p><p>(m,n)门限方案指的是任意持有一部分密钥的m个人都能解密，而任何少于m个人都不能解密</p><p>参考链接：<a href="http://coinc1dens.me/2021/07/01/Some_other_cryptosystem.html#shamirs-secret-sharing-algorithm">一些密码系统 - Coinc1dens’ Diary</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文参考：</p><p>CTF WIKI</p><p><a href="http://coinc1dens.me/2021/07/01/Some_other_cryptosystem.html#shamirs-secret-sharing-algorithm">一些密码系统 - Coinc1dens’ Diary</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Crypto</category>
      
      <category>理论学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>流密码</title>
    <link href="/2021/09/06/%E6%B5%81%E5%AF%86%E7%A0%81/"/>
    <url>/2021/09/06/%E6%B5%81%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="流密码综述"><a href="#流密码综述" class="headerlink" title="流密码综述"></a>流密码综述</h1><p>流密码又称为序列密码，它是密码学的一个重要部分。在CTF的密码学中，流密码一般都以以下的几种情形出现：</p><ul><li><p>线性同余发生器（LCG）</p></li><li><p>MT19937（python随机数库的预测）</p></li><li><p>线性反馈移位寄存器（LFSR）和非线性反馈移位寄存器（NFSR）</p></li><li><p>RC4</p><p>其中，重点和难点应该是在LFSR和它所衍生出的一系列算法。下面总结一下流密码。</p><h1 id="线性同余发生器（LCG）"><a href="#线性同余发生器（LCG）" class="headerlink" title="线性同余发生器（LCG）"></a>线性同余发生器（LCG）</h1><p>形如$X_{n+1}\equiv aX_n+b\ (mod\ m)$（$X_0为已知种子$），若$gcd(a,m)=1$，则LCG可以取得最大周期（遍历所有可能结果）。</p><h2 id="一般题型"><a href="#一般题型" class="headerlink" title="一般题型"></a>一般题型</h2><p>对于LCG的一般情况下的攻击可分为两类，一类是a,b未知，另一类是a,b,m都未知。</p><p>对于前者，我们只需要知道连续的三个生成值，即可通过解模线性方程组求解。</p><p>对于后者，已知连续的五个生成值，我们可以通过构造模等比数列，再通过求gcd的方法求得m的值，接下来的过程就很好办了。</p><p>参考链接：<a href="https://zeroyu.xyz/2018/11/02/Cracking-LCG/">攻击线性同余生成器(LCG) (zeroyu.xyz)</a></p><h2 id="创新题型"><a href="#创新题型" class="headerlink" title="创新题型"></a>创新题型</h2><p>在Van1sh神的blog里面，有一篇介绍HNP（Hidden Number Probem）的文章,题目给出了a,b,m的值，生成了20个128位的随机数，但是只给出了每个数的高64位，然后题目的重点是恢复原来的seed。关于HNP问题的内容仍在学习中，等学明白了再将这一块更新。先给出V神文章链接：</p><p><a href="https://www.anquanke.com/post/id/204846">浅尝lattice之HNP</a></p><h1 id="python随机数——MT19937"><a href="#python随机数——MT19937" class="headerlink" title="python随机数——MT19937"></a>python随机数——MT19937</h1><p>CTF一般随机数攻击方法：爆破或者预测</p><p>预测python随机数的库：randcrack</p><p>可在泄露624个连续随机数后进行预测</p><h1 id="线性反馈移位寄存器（LFSR）"><a href="#线性反馈移位寄存器（LFSR）" class="headerlink" title="线性反馈移位寄存器（LFSR）"></a>线性反馈移位寄存器（LFSR）</h1><p>这一块一般题型都不难，但是水比较深，涉及到很多代数知识和分析方法如Galois理论还有GF（2）域上的多项式代数以及相关攻击、快速相关攻击、B-M算法，这段时间把这些都学会。</p><p>待更新。</p><h1 id="非线性反馈移位寄存器（NFSR）"><a href="#非线性反馈移位寄存器（NFSR）" class="headerlink" title="非线性反馈移位寄存器（NFSR）"></a>非线性反馈移位寄存器（NFSR）</h1><p>待更新。</p><h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><p>待更新。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Crypto</category>
      
      <category>理论学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>相关消息攻击</title>
    <link href="/2021/09/02/%E7%9B%B8%E5%85%B3%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB/"/>
    <url>/2021/09/02/%E7%9B%B8%E5%85%B3%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>本文介绍的是相关消息攻击。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ycdxsb.cn/2decc525.html">https://ycdxsb.cn/2decc525.html</a></p></li><li><p><a href="https://xz.aliyun.com/t/6813#toc-2">https://xz.aliyun.com/t/6813#toc-2</a></p></li><li><p>《Low-Exponent RSA with Related Messages 》by Coppersmith, Franklin, Patarin and Reiter</p></li><li><p>《Solving Systems of Modular Equations in OneVariable: How Many RSA-Encrypted MessagesDoes Eve Need to Know?》by Alexander May, Maike Ritzenhofent</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li><p>RSA原理</p></li><li><p>lattice和LLL算法</p></li><li><p>多项式代数</p><h2 id="使用工具-库"><a href="#使用工具-库" class="headerlink" title="使用工具/库"></a>使用工具/库</h2><ul><li>sagemath</li><li>python的gmpy2库</li></ul></li></ul><h1 id="线性相关消息"><a href="#线性相关消息" class="headerlink" title="线性相关消息"></a>线性相关消息</h1></li></ul><h2 id="k-2（k为消息数）"><a href="#k-2（k为消息数）" class="headerlink" title="k=2（k为消息数）"></a>k=2（k为消息数）</h2><p>假设两则相关消息满足：</p><script type="math/tex; mode=display">(a_1m+b_1)^e \equiv c_1\ (mod\ n)\\(a_2m+b_2)^e \equiv c_2\ (mod\ n)</script><p>那么模多项式$(a_1m+b_1)^e-c_1\ (mod\ n)$和$(a_2m+b_2)^e-c_2\ (mod\ n)$一般来说会存在一个形如<script type="math/tex">m-m_0</script>的$gcd$，对这两个多项式在模n下求$gcd$，得到$m-m_0$，$m_0$即为我们要求的$m$。对于这两个多项式$gcd$不为线性函数的情况，本文暂不讨论。</p><h2 id="k-gt-2（k为消息数"><a href="#k-gt-2（k为消息数" class="headerlink" title="k&gt;2（k为消息数)"></a>k&gt;2（k为消息数)</h2><p>假设k则消息之间满足多项式：</p><script type="math/tex; mode=display">p(x_1,x_2,...,x_k)=0</script><p>并且有：</p><script type="math/tex; mode=display">p_1(x_1)=x_1^e-c_1=0\ (mod\ n)</script><script type="math/tex; mode=display">p_2(x_2)=x_2^e-c_2=0\ (mod\ n)</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">p_i(x_i)=x_i^e-c_i=0\ (mod\ n)</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">p_k(x_k)=x_k^e-c_k=0\ (mod\ n)</script><p>然后我们求出它们的Groebner基，即可求</p><p>得$x_i=m_i$，对于这k个式子，可求出k个解，这k个解即为我们要找的解。</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>通过我们的的操作可以看出，其实这里并不局限于线性相关，在这里多项式相关都是可以的，所以此处改为“多项式相关消息”可能更准确。</p><h1 id="Hastad广播攻击"><a href="#Hastad广播攻击" class="headerlink" title="Hastad广播攻击"></a>Hastad广播攻击</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前面介绍的相关消息攻击模数都是一样的，Hastad广播攻击中则对模数不同的攻击进行了讨论。</p><h2 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h2><p>对于使用不同的但是互素的模数n，相同的加密指数e，加密e个明文得到e个密文：</p><script type="math/tex; mode=display">(a_ix+b_i)^e \equiv c_i\ (mod\ n_i)\ ,\ i=1,2,...,e</script><p>由于模数互素，我们通过多项式的中国剩余定理，可以得到$P(x)\equiv 0\ (mod\ M)，M=\prod_{i=1}^en_i$，$P(x)$存在唯一解，并且这个解满足LLL算法的条件，所以我们可以据此求出解，得到x，恢复明文。</p><h1 id="SMUPE问题"><a href="#SMUPE问题" class="headerlink" title="SMUPE问题"></a>SMUPE问题</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>无论是前面的线性相关消息攻击（多项式相关消息攻击），还是Hastad广播攻击，我们尽管使用了不同的模数n，但我们使用的指数e都是一样的。在SMUPE问题（systems of modular univariate polynomial equations）中，我们使用的加密指数e也可以不同，如：</p><script type="math/tex; mode=display">(a_ix+b_i)^{e_i}\equiv c_i\ (mod\ n_i)\ ,\ i=1,2,...,k\\记f_i(x)=(a_ix+b_i)^{e_i}</script><p>此时由于模数不同，我们无法直接使用中国剩余定理，因此需要构造同阶的多项式。</p><p>为了构造这样的多项式，Hastad采取了两边同时乘$(a_ix+b_i)^{\delta-\delta_i}$的方法来统一阶数，其中$\delta$为最高次数。</p><p>而在论文《Solving Systems of Modular Equations in OneVariable: How Many RSA-Encrypted MessagesDoes Eve Need to Know?》by Alexander May, Maike Ritzenhofent 中，他们提出了另外一种更有效的平衡阶数的方法，用阶数的最小公倍数来构造（在这里$\delta_i$的意义和$e_i$一样）：</p><script type="math/tex; mode=display">[f_i(x)]^{\delta/\delta_i}\equiv c_i^{\delta/\delta_i}\ (mod\ n_i)\ , \ i=1,2,...,k\ ,\ \delta=lcm(\delta_j,j=1,2,...,k)</script><p>这里的所有多项式都是首一的多项式（$monic\ polynomial$）.</p><p>此时可以用中国剩余定理解决，作者们证明了这种攻击能够成功的条件为（满足LLL算法的条件）：</p><script type="math/tex; mode=display">\sum_{i=1}^k1/\delta_i≥1</script><hr><p>本文对相关消息攻击的讨论大致就如上所述，本文为理论性学习文章，因此不涉及代码部分，解题方面还需移步CTF-Crypto-题目实践。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Crypto</category>
      
      <category>理论学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Love_DengFeng&#39;s Blog</title>
    <link href="/2021/08/30/Love_DengFeng&#39;s%20Blog/"/>
    <url>/2021/08/30/Love_DengFeng&#39;s%20Blog/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><hr><p><strong><em>2021年8月29日</em></strong>，我终于把自己很早之前的想法付诸实践了——搭建一个自己的博客站点，来记录自己的学习历程，同时分享一些个人的想法以及学习的内容来跟各位 $dalao$ 互相交流学习。<strong><em>8月30日</em></strong>，AK了 $DASCTF$ 八月挑战赛 $Crypto$ 部分后（本人很菜，是题目太简单了），大概熟悉了博客的管理运行发布删除等操作以及用 $markdown$ 写博客的方法后，写下这第一篇博客来开启我的学习记录路程。最近几个月的重心应该还是会放在 $CTF$ 的 $Crypto$ 方向上，提高自己的水平，期待自己能得到更大的提升。</p><script type="math/tex; mode=display">联系方式：</script><script type="math/tex; mode=display">QQ:1440416491</script><script type="math/tex; mode=display">E-mail:1440416491@qq.com</script><p>这是<a href="https://www.zhihu.com/people/deng-feng-10-87-48">我的知乎</a>，里面记录了一些数论的理论，dalao们不妨关注一波，<del>给我加一点关注量</del>说不定能学到一点点东西。</p><p>欢迎各路$dalao$交流学习！</p>]]></content>
    
    
    <categories>
      
      <category>introduction</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
