<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>IELTS Writing(PART1)</title>
    <link href="/2021/12/14/IELTS%E9%80%89%E4%BF%AE%E8%AF%BE%E4%BD%9C%E6%96%87/"/>
    <url>/2021/12/14/IELTS%E9%80%89%E4%BF%AE%E8%AF%BE%E4%BD%9C%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h2 id="表示变化趋势"><a href="#表示变化趋势" class="headerlink" title="表示变化趋势"></a>表示变化趋势</h2><h3 id="下降"><a href="#下降" class="headerlink" title="下降"></a>下降</h3><p>fall                        drop                      go down    downturn</p><p>downward trend          reach a low      decrease</p><p>decline                 be reduced           <strong>sag</strong></p><p><strong>sink</strong>                 <strong>descend</strong>             <strong>dwindle</strong></p><p><strong>peter out(逐渐消失)</strong>      <strong>dip(小降)</strong>         </p><p><strong>plunge</strong>          <strong>plummet</strong>             <strong>collapse</strong>         <strong>slump</strong>         ——猛降 </p><h3 id="上升"><a href="#上升" class="headerlink" title="上升"></a>上升</h3><p>rise               reach a high                 upward trend</p><p>increase            climb                   grow</p><p><strong>ascend</strong>           <strong>mount(up)</strong>               <strong>shoot up</strong></p><p><strong>soar</strong>                <strong>surge</strong>                 <strong>skyrocket</strong>       ——猛增 </p><h3 id="持平"><a href="#持平" class="headerlink" title="持平"></a>持平</h3><p>keep unchanging       stay the same           remain fixed</p><p>remain stable            keep constant</p><p><strong>level off/out at</strong>         <strong>stabilise around</strong>       <strong>remain static</strong></p><p><strong>reach a plateau(上升后持平)</strong>         <strong>stagnate</strong></p><h4 id="noun"><a href="#noun" class="headerlink" title="noun"></a>noun</h4><p>level-off           stabilisation             stagnate</p><h3 id="波动"><a href="#波动" class="headerlink" title="波动"></a>波动</h3><p><strong>fluctuate</strong>             <strong>surge and subside</strong>                 <strong>undulate</strong></p><p><strong>increase in fits and starts</strong>             <strong>erratic changes</strong></p><p><strong>turbulent changes</strong></p><h3 id="达到峰值"><a href="#达到峰值" class="headerlink" title="达到峰值"></a>达到峰值</h3><p>reach the peak of                       peak up at                arrive at the top</p><p><strong>crest</strong>                          <strong>culminate</strong>                          <strong>hit the prime at</strong>      （碰撞素数？doge)</p><p><strong>culmination</strong>                     <strong>pinnacle</strong>                   <strong>acme</strong>             <strong>zenith</strong></p><h3 id="达到谷值"><a href="#达到谷值" class="headerlink" title="达到谷值"></a>达到谷值</h3><p>drop to the valley             drop to the bottom             reach the lowest point</p><p><strong>bottom out at</strong>                  <strong>go down to the trough</strong>       reach a low of</p><p><strong>nadir</strong></p><h3 id="猛、快"><a href="#猛、快" class="headerlink" title="猛、快"></a>猛、快</h3><p>steep             sharp             dramatic          considerable</p><p><strong>drastic</strong>              <strong>substantial</strong>             overwhelming</p><p>noticeable           <strong>striking</strong>          <strong>precipitous</strong>(一般指下降快)</p><p><strong>grow/drop by a whopping__</strong></p><h3 id="稳"><a href="#稳" class="headerlink" title="稳"></a>稳</h3><p>stable     steady          gradual</p><p>smooth            moderate           modest</p><h3 id="缓"><a href="#缓" class="headerlink" title="缓"></a>缓</h3><p>slight        slow         gentle              mild                 <strong>marginal</strong></p><h3 id="起点-终点"><a href="#起点-终点" class="headerlink" title="起点/终点"></a>起点/终点</h3><p>start from           begin with               finish at               end with</p><h3 id="加速-减速"><a href="#加速-减速" class="headerlink" title="加速/减速"></a>加速/减速</h3><p> gain speed                speed up                  slow down           lose speed</p><h2 id="高级表述"><a href="#高级表述" class="headerlink" title="高级表述"></a>高级表述</h2><p>The population of female smokers only rose by 1%</p><p><strong>The population of female smokers rose by a negligible 1%</strong></p><p>The difference was getting smaller.</p><p> <strong>The disparity was diminishing.</strong></p><p> People of all education backgrounds had a pay-rise. </p><p><strong>There was a pay-rise across the board. </strong></p><p>since 1940= starting from 1940</p><p><strong>from 1940 onwards</strong></p><p>The higher the education levels were, the higher the incomes were. </p><p><strong>The education levels were in positive correlation with the incomes.</strong></p><p><strong>The education levels were proportionate to the incomes.</strong></p><p>成反比就是<strong>be in negative correlation with be in inverse</strong></p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>雅思选修课</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯赛前学习和刷题（第一天）</title>
    <link href="/2021/11/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%B5%9B%E5%89%8D%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%88%B7%E9%A2%98%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89/"/>
    <url>/2021/11/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%B5%9B%E5%89%8D%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%88%B7%E9%A2%98%EF%BC%88%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>01背包是最基础的背包问题，也是其他背包问题的基础，很多其他背包问题都可以化归为01背包问题，因此，01背包是一种很基础、很重要的背包问题。</p><p>01背包问题的描述如下：</p><script type="math/tex; mode=display">一共有N件物品，第i件（从1开始）物品的重量为w[i]，价值为v[i]，背包容量为W，求在不超出背包容量的前提下，背包最多能装的价值？</script><p>穷举法复杂度太高，不可行。这是动态规划问题的经典题之一，我们采用动态规划的方法对它进行求解。</p><p>动态规划的三个步骤：</p><p>1.定义数组的含义</p><p>2.建立状态转移方程</p><p>3.遍历数组，求出答案</p><script type="math/tex; mode=display">设dp[i][j]表示将前i件物品装入限重为j的背包可获得的最大价值</script><p>不装入第i件物品：$dp[i-1][j]$</p><p>装入第i件物品（前提是能装下），即$dp[i-1][j-w[i]]+v[i]$</p><p>状态转移方程为： $dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])$</p><p>由转移方程可知，$dp[i][j]的值只与dp[i-1][0,…,j-1]有关$，因此我们可以采用滚动数组的方法来优化空间复杂度，注意为了避免上一层循环被覆盖，循环的时候j只能逆向枚举，伪代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[<span class="hljs-number">0</span>,...,W]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>,...,N:<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> W,...w[i]:<br>        dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-w[i]]+v[i])<br></code></pre></td></tr></table></figure><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>完全背包跟01背包很相似，它们的差别就在于完全背包每种物品有无限多个，其他条件一致。这里的数组定义和01背包一致，但是状态转移方程发生了改变——当装入第i种物品后，还可以继续装这个物品，因此转移到$dp[i][j-w[i]]而不是dp[i-1][j-w[i]]$，于是状态转移方程为$dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i])$，我们也可以对其进行空间复杂度优化，但此时我们应该正向枚举去覆盖原有结果，伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[<span class="hljs-number">0</span>,...W]=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,...,N:<br>    <span class="hljs-keyword">for</span> j =w[i],...,W:<br>        dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-w[i]]+v[i])<br></code></pre></td></tr></table></figure><h2 id="另一种分析方法"><a href="#另一种分析方法" class="headerlink" title="另一种分析方法"></a>另一种分析方法</h2><p>01背包只有两种选择即取0件和取1件，但是完全背包可以取0，1，2，…，直到超过限重($k&gt;j/w[i]$)，所以状态转移方程为：$dp[i][j]=max((dp[i-1][j-k<em>w[i]]+k</em>v[i]) for\ every \ k)$</p><p>上面也可以进行空间复杂度的优化，但要注意这里的max里面是dp[i-1]，和01背包一样，必须逆向枚举，优化后的伪代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[<span class="hljs-number">0</span>,...,W]=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i =<span class="hljs-number">1</span>,...,N:<br>    <span class="hljs-keyword">for</span> j =W,...,w[i]:<br>        <span class="hljs-keyword">for</span> k = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,...,j/w[i]]:<br>            dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-k*w[i]]+k*v[i])<br></code></pre></td></tr></table></figure><h2 id="还有一种分析方法"><a href="#还有一种分析方法" class="headerlink" title="还有一种分析方法"></a>还有一种分析方法</h2><p>还有一种方法，就是把完全背包转化为01背包，可采用二进制转换的方法转为01背包，这里暂不做讨论。</p><h1 id="剪枝策略"><a href="#剪枝策略" class="headerlink" title="剪枝策略"></a>剪枝策略</h1><p>如果有更物美价廉的物品，就把贵又不值的物品扔去。</p><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>多重背包和前面两种背包很相似，只是它每种物品的数量既不是1，也不是无穷，而是有限个n[i]，分析跟完全背包的分析二相近，伪代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[<span class="hljs-number">0</span>,...,W]=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i= <span class="hljs-number">1</span>,...,N:<br>    <span class="hljs-keyword">for</span> j = W,...,w[i]:<br>        <span class="hljs-keyword">for</span> k = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,...,<span class="hljs-built_in">min</span>(n[i],j/w[i])]:<br>            dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-k*w[i]]+k*v[i])<br></code></pre></td></tr></table></figure><p>还可以像完全背包分析三的方法转为二进制化成01背包求解来求解。</p><h1 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h1><p>如果物品有的只有一件，有的有有限件，有的有无穷件，那么这样的问题叫做混合背包问题。如果是01背包和完全背包混合的话，根据物品类别确定顺序和逆序即可；如果再加上多重背包，用单调队列解即可。另外一种可行的方法是把多重背包转为01背包，虽然复杂度稍稍变大，但也已经很优秀了。</p><h1 id="二维背包"><a href="#二维背包" class="headerlink" title="二维背包"></a>二维背包</h1><p>二维背包是指对于每件物品，具有两种不同的费用，选择一件物品要付出两种代价，对于每种代价都有可付出的最大值（也即背包容量）。设第i件物品所需的两种代价分别为a[i]和b[i]，两种代价的最大值（背包容量）分别为V和U，物品的价值为c[i]。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>费用增加一维，状态增加一维即可。设f[i] [v] [u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。</p><p>状态转移方程就是：$f[i][v][u]=max(f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+c[i])$，类似的，这里也可以采用滚动数组的方式优化空间复杂度，并且当每件物品只可以取一次时v和u采用逆序的循环，当物品有如完全背包时采用顺序的循环；如多重背包时拆分物品。</p><h1 id="隐藏的二维背包"><a href="#隐藏的二维背包" class="headerlink" title="隐藏的二维背包"></a>隐藏的二维背包</h1><p>有时二维背包这样隐含地说出来：最多只能取M件物品。这就相当于每件物品多了件数这一代价，可付出的代价最大为M。这样再根据每种物品可取件数采取01背包还是完全背包还是多重背包。如果要求恰好取M件，那么就在$f[0…V][M]$中寻找答案。</p><h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><p>分组背包指每一组的物品互斥的背包问题。将每组看成一个大物品，再从大物品里面选择小物品，因此只需要加一层循环即可。</p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 所有组k:<br>    <span class="hljs-keyword">for</span> v=V,..<span class="hljs-number">.0</span>:<br>        <span class="hljs-keyword">for</span> 所有的i 属于组k:<br>            f[v]=<span class="hljs-built_in">max</span>(f[v],f[v-w[i]]+c[i])<br></code></pre></td></tr></table></figure><p>显然这里也可以进行一个小剪枝。</p><h1 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h1><p>待补充</p><h1 id="求背包问题方案数"><a href="#求背包问题方案数" class="headerlink" title="求背包问题方案数"></a>求背包问题方案数</h1><p>将max改为sum即可，这样是因为状态转移方程已经考察了所有的可能背包组成方案。</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
      <category>DP</category>
      
      <category>背包问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分组密码AES和DES</title>
    <link href="/2021/09/12/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81AES%E5%92%8CDES/"/>
    <url>/2021/09/12/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81AES%E5%92%8CDES/</url>
    
    <content type="html"><![CDATA[<h1 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h1><p>DES是一种典型的Feistel结构密码体制，它使用长度为56比特的密钥加密（解密）长度为64比特的明文（密文），获得长度为64比特的密文（明文）。其加密流程如下：</p><p>1.传入64比特的明文，进行IP置换</p><p>2.通过密钥扩展算法获得轮密钥，扩展算法为：将初始密钥进行PC-1置换后得到$C_0,D_0$两部分，再进行本轮的循环移位后进入PC-2置换（从56比特选取48比特）得到轮密钥。下一轮的轮密钥和上一轮的轮密钥关系为：</p><script type="math/tex; mode=display">C_i=C_{i-1}<<<<r_i</script><script type="math/tex; mode=display">D_i=D_{i-1}<<<<r_i</script><script type="math/tex; mode=display">K_i=PC-2(C_iD_i)</script><p>3.初始置换后的明文分为左右两部分，进入轮密钥控制的16次F函数（轮函数）迭代（Feistel结构），前十五次的迭代方式为：$L<em>i=R</em>{i-1}，R<em>i=L</em>{i-1}+F(R_{i-1},K_i)$，最后一次的迭代方式稍稍不一样，为：</p><script type="math/tex; mode=display">L_{16}=L_{15}+F(R_{15},K_{16}),R_{16}=R_{15}</script><p>这里的”+”代表异或，最后一次不同的原因是为了保证加解密的一致性——若加密采用的轮密钥为$(K<em>1,K_2,…,K</em>{16})$，则解密采用轮密钥为$(K<em>{16},K</em>{15},…,K_1)$，并且加解密流程采用完全相同的结构和轮函数</p><p>4.进行初始逆置换$IP^{-1}$，得到密文</p><h2 id="核心轮函数F"><a href="#核心轮函数F" class="headerlink" title="核心轮函数F"></a>核心轮函数F</h2><p>1.将输入的32比特通过扩展函数E变为48比特</p><p>2.将得到的48比特与子密钥异或后进入S盒，作为S盒的输入</p><p>3.S盒是一个非线性变换，它将输入通过8个并置的6进4出（比特位）的S盒压缩成32比特。每个S盒都有一张替换表，替换表都有4行16列，对应前十六个整数（长度为4的比特串）的二进制整数全排列。设S盒的输入为$a_1a_2a_3a_4a_5a_6$，则$S(a_1a_2a_3a_4a_5a_6)$就是S盒表中第$a_1a_6$行和第$a_2a_3a_4a_5$列交叉的那个数，这里的$a_1a_6 $和$a_2a_3a_4a_5 $都是二进制整数</p><p>4.将S盒得到的32位比特输出作为输入进行P置换，P置换的结果就是轮函数的输出</p><h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>AES即美国国家高级加密标准（$Advanced\ Encryption\ Standard$），其算法为$Rijndael$算法，分组长度通常为128比特，密钥长度通常也为128比特，加密轮数为10轮</p><h2 id="加密步骤"><a href="#加密步骤" class="headerlink" title="加密步骤"></a>加密步骤</h2><p>首先将输入的明文分组为16个字节$a<em>{00}a</em>{10}a<em>{20}a</em>{30}a<em>{01}a</em>{11}a<em>{21}a</em>{31}a<em>{02}a</em>{12}a<em>{22}a</em>{32}a<em>{03}a</em>{13}a<em>{23}a</em>{33}$，并+按照顺序映射为状态字节矩阵，加密操作结束时，密文按同样顺序从状态抽取，映射顺序为：</p><script type="math/tex; mode=display">\begin{pmatrix}a_{00}&a_{01}&a_{02}&a_{03}\\a_{10}&a_{11}&a_{12}&a_{13}\\a_{20}&a_{21}&a_{22}&a_{23}\\a_{30}&a_{31}&a_{32}&a_{33}\\\end{pmatrix}</script><p>1.由密钥拓展算法将128比特的种子密钥拓展成11个128比特的轮密钥，每一个轮密钥同样被表示成与明文状态矩阵大小相同的矩阵</p><p>2.进行初始白化：将明文状态矩阵与第0轮的轮密钥进行加法运算</p><p>3.进行完全相同的9轮变换，每一轮变换都是以上一轮的输出作为输入，依次执行字节替换、行移位、列混合和轮密钥加四种运算</p><p>4.最后一轮的迭代变换稍有不同，这一轮变换依次执行字节替换、行移位和轮密钥加，没有列混合</p><p>5.将最后一轮输出的结果按照顺序从状态中抽取出来就是密文</p><h3 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h3><p>状态矩阵每一行按照不同的移位值进行循环左移</p><h3 id="列混合（列混淆）"><a href="#列混合（列混淆）" class="headerlink" title="列混合（列混淆）"></a>列混合（列混淆）</h3><p>将状态矩阵每一列看作$GF(2^8)$域上的次数不超过3的多项式，与下列矩阵作乘法运算</p><script type="math/tex; mode=display">\begin{pmatrix}02&03&01&01\\01&02&03&01\\01&01&02&03\\03&01&01&02\\\end{pmatrix}</script><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>此处的加法应理解为域上的加法运算（与异或等价）</p><h3 id="密钥扩展方案"><a href="#密钥扩展方案" class="headerlink" title="密钥扩展方案"></a>密钥扩展方案</h3><p>待补充</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Crypto</category>
      
      <category>理论学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>密码系统</title>
    <link href="/2021/09/08/%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/09/08/%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Diffie-Hellman"><a href="#Diffie-Hellman" class="headerlink" title="Diffie-Hellman"></a>Diffie-Hellman</h1><p>Diffie-Hellman密钥交换。</p><p>基于离散对数困难问题。</p><h1 id="ElGamal"><a href="#ElGamal" class="headerlink" title="ElGamal"></a>ElGamal</h1><p>基于离散对数问题。</p><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>1.选取足够大的素数p保证p-1存在很大的素因子，使得在$Z_p$上求解离散对数问题是困难的</p><p>2.选取$Z_p ^*$的生成元g</p><p>3.随机选取整数k满足$0≤k≤p-2$，并计算$g^k\equiv y\ (mod\ p)$</p><p>公钥为{$p,g,y$}，私钥为{$k$}。</p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>选取一个随机整数$r\in Z_{p-1}$，得到密文$(y_1,y_2)=(g^rmod\ p,my^rmod\ p)$，其中m为要发送的消息（明文）。</p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>解密时，通过私钥k计算$(y_1^k)^{-1}y_2mod\ p=(g^{rk})^{-1}my^rmod\ p=m$.</p><p>参考CTF WIKI</p><h1 id="Paillier-Cryptosystem"><a href="#Paillier-Cryptosystem" class="headerlink" title="Paillier Cryptosystem"></a>Paillier Cryptosystem</h1><h2 id="密钥生成-1"><a href="#密钥生成-1" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>一般过程：</p><p>1.随机选择两个大素数p,q满足$gcd(pq,(p-1)(q-1))=1$，当p,q长度相同时一定有该结论</p><p>2.计算$n=pq，\lambda=lcm(p-1,q-1)=(p-1)(q-1)/gcd(p-1,q-1)$</p><p>3.随机选取整数$g,0&lt;g&lt;n^2$</p><p>4.$L(x)=(x-1)/n$</p><p>5.计算$\mu=(L(g^\lambda(mod\ n^2)))^{-1}\ (mod\ n)$</p><p>6.公钥为（n，g），私钥为（$\lambda，\mu$）</p><p>特殊情况：</p><p>通常，为简便，我们参数选取如下：</p><p>1.$g=n+1$</p><p>2.$\lambda=\varphi(n)$</p><p>3.$\mu=\varphi(n)^{-1}\ (mod\ n)$</p><h2 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h2><p>1.m为要发送的消息（明文），满足$0≤m&lt;n$</p><p>2.随机选取r，使得$gcd(r,n)=1$</p><p>3.密文$c:c=g^m\cdot r^n\ (mod\ n)$</p><h2 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h2><p>$m=(L(c^\lambda\ (mod\ n^2))\cdot\mu)\ (mod\ n)$</p><h1 id="同态性质"><a href="#同态性质" class="headerlink" title="同态性质"></a>同态性质</h1><p>$D(E(m_1,r_1)\cdot E(m_2,r_2))\ (mod\ n^2)=m_1+m2\ (mod\ n$)</p><p>$D(E(m,r)^k\ mod\ n^2)=km\ mod\ n$</p><h1 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h1><ul><li><p>同态性质攻击</p></li><li><p>选择明文攻击</p><p>参考：<a href="http://coinc1dens.me/2021/07/01/Some_other_cryptosystem.html">一些密码系统 - Coinc1dens’ Diary</a></p></li></ul><h1 id="DSA-System"><a href="#DSA-System" class="headerlink" title="DSA System"></a>DSA System</h1><p>与前面的不同，DSA算法是一种数字签名算法，一般不用于加解密</p><h2 id="密钥生成-2"><a href="#密钥生成-2" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>1.选择合适的哈希函数，一般选择SHA-1</p><p>2.选择密钥的长度L和N，这两个值决定了签名的安全程度。一般来说L为64的倍数，且$512≤L≤1024$，N必须不大于哈希函数H输出的长度</p><p>3.选择N比特的素数q</p><p>4.选择L比特的素数p，使得$q|p-1$</p><p>5.选择满足$g^k\equiv1\ mod\ p$的最小正整数k为q的g（即g的阶为q）。在这里，我们可以通过计算$g\equiv h^{p-1\over q}\ mod\ p$来得到g，其中$1&lt;h&lt;p-1$.</p><p>6.选择私钥x，$0&lt;x&lt;q$，计算$y\equiv g^x\ mod\ p$</p><p>公钥为（p,q,g,y)，私钥为(x).</p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>签名步骤：</p><p>1.选择随机整数k作为临时密钥,$0&lt;k&lt;q$</p><p>2.计算$r\equiv(g^k\ mod\ p)\ mod\ q$</p><p>3.计算$s\equiv(H(m)+xr)k^{-1}\ mod\ q$</p><p>签名结果为（r，s）</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证步骤：</p><p>1.计算辅助量，$w\equiv s^{-1}\ mod\ q$</p><p>2.计算辅助量，$u_1\equiv H(m)w\ mod\ q$</p><p>3.计算辅助量，$u_2\equiv rw\ mod\ q$</p><p>4.计算$v\equiv (g^{u_1}y^{u_2}\ mod\ p)\ mod\ q$</p><p>5.如果有$v=r$，则验证成功</p><h2 id="攻击方法-1"><a href="#攻击方法-1" class="headerlink" title="攻击方法"></a>攻击方法</h2><h3 id="k泄露"><a href="#k泄露" class="headerlink" title="k泄露"></a>k泄露</h3><p>如果我们知道了k，那么我们可以获取私钥为：</p><script type="math/tex; mode=display">x\equiv r^{-1}(ks-H(m))\ mod\ q</script><h3 id="k共享"><a href="#k共享" class="headerlink" title="k共享"></a>k共享</h3><p>如果在两次签名过程使用了同一个k，这时我们可以攻击。</p><p>假设签名的消息为$m_1,m_2$，显然，两者的r值相同，我们还有：</p><script type="math/tex; mode=display">s_1\equiv (H(m_1)+xr)k^{-1}\ mod\ q</script><script type="math/tex; mode=display">s_2\equiv (H(m_2)+xr)k^{-1}\ mod\ q</script><p>化为：</p><script type="math/tex; mode=display">s_1k\equiv H(m_1)+xr</script><script type="math/tex; mode=display">s_2k\equiv H(m_2)+xr</script><p>两式相减</p><script type="math/tex; mode=display">k(s_1-s_2)\equiv H(m_1)-H(m_2)\ mod\ q</script><p>此时我们可以解出k，进一步可以解出x</p><h3 id="进阶攻击方法"><a href="#进阶攻击方法" class="headerlink" title="进阶攻击方法"></a>进阶攻击方法</h3><p>MSB泄露攻击（HNP问题的方法），借助格和LLL算法，待补充</p><h1 id="Shamir’s-Secret-Sharing-Algorithm"><a href="#Shamir’s-Secret-Sharing-Algorithm" class="headerlink" title="Shamir’s Secret Sharing Algorithm"></a>Shamir’s Secret Sharing Algorithm</h1><p>基于拉格朗日插值法（也可理解为方程组的秩）</p><p>(m,n)门限方案指的是任意持有一部分密钥的m个人都能解密，而任何少于m个人都不能解密</p><p>参考链接：<a href="http://coinc1dens.me/2021/07/01/Some_other_cryptosystem.html#shamirs-secret-sharing-algorithm">一些密码系统 - Coinc1dens’ Diary</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文参考：</p><p>CTF WIKI</p><p><a href="http://coinc1dens.me/2021/07/01/Some_other_cryptosystem.html#shamirs-secret-sharing-algorithm">一些密码系统 - Coinc1dens’ Diary</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Crypto</category>
      
      <category>理论学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>流密码</title>
    <link href="/2021/09/06/%E6%B5%81%E5%AF%86%E7%A0%81/"/>
    <url>/2021/09/06/%E6%B5%81%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="流密码综述"><a href="#流密码综述" class="headerlink" title="流密码综述"></a>流密码综述</h1><p>流密码又称为序列密码，它是密码学的一个重要部分。在CTF的密码学中，流密码一般都以以下的几种情形出现：</p><ul><li><p>线性同余发生器（LCG）</p></li><li><p>MT19937（python随机数库的预测）</p></li><li><p>线性反馈移位寄存器（LFSR）和非线性反馈移位寄存器（NFSR）</p></li><li><p>RC4</p><p>其中，重点和难点应该是在LFSR和它所衍生出的一系列算法。下面总结一下流密码。</p><h1 id="线性同余发生器（LCG）"><a href="#线性同余发生器（LCG）" class="headerlink" title="线性同余发生器（LCG）"></a>线性同余发生器（LCG）</h1><p>形如$X_{n+1}\equiv aX_n+b\ (mod\ m)$（$X_0为已知种子$），若$gcd(a,m)=1$，则LCG可以取得最大周期（遍历所有可能结果）。</p><h2 id="一般题型"><a href="#一般题型" class="headerlink" title="一般题型"></a>一般题型</h2><p>对于LCG的一般情况下的攻击可分为两类，一类是a,b未知，另一类是a,b,m都未知。</p><p>对于前者，我们只需要知道连续的三个生成值，即可通过解模线性方程组求解。</p><p>对于后者，已知连续的五个生成值，我们可以通过构造模等比数列，再通过求gcd的方法求得m的值，接下来的过程就很好办了。</p><p>参考链接：<a href="https://zeroyu.xyz/2018/11/02/Cracking-LCG/">攻击线性同余生成器(LCG) (zeroyu.xyz)</a></p><h2 id="创新题型"><a href="#创新题型" class="headerlink" title="创新题型"></a>创新题型</h2><p>在Van1sh神的blog里面，有一篇介绍HNP（Hidden Number Probem）的文章,题目给出了a,b,m的值，生成了20个128位的随机数，但是只给出了每个数的高64位，然后题目的重点是恢复原来的seed。关于HNP问题的内容仍在学习中，等学明白了再将这一块更新。先给出V神文章链接：</p><p><a href="https://www.anquanke.com/post/id/204846">浅尝lattice之HNP</a></p><h1 id="python随机数——MT19937"><a href="#python随机数——MT19937" class="headerlink" title="python随机数——MT19937"></a>python随机数——MT19937</h1><p>CTF一般随机数攻击方法：爆破或者预测</p><p>预测python随机数的库：randcrack</p><p>可在泄露624个连续随机数后进行预测</p><h1 id="线性反馈移位寄存器（LFSR）"><a href="#线性反馈移位寄存器（LFSR）" class="headerlink" title="线性反馈移位寄存器（LFSR）"></a>线性反馈移位寄存器（LFSR）</h1><p>这一块一般题型都不难，但是水比较深，涉及到很多代数知识和分析方法如Galois理论还有GF（2）域上的多项式代数以及相关攻击、快速相关攻击、B-M算法，这段时间把这些都学会。</p><p>待更新。</p><h1 id="非线性反馈移位寄存器（NFSR）"><a href="#非线性反馈移位寄存器（NFSR）" class="headerlink" title="非线性反馈移位寄存器（NFSR）"></a>非线性反馈移位寄存器（NFSR）</h1><p>待更新。</p><h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><p>待更新。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Crypto</category>
      
      <category>理论学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>相关消息攻击</title>
    <link href="/2021/09/02/%E7%9B%B8%E5%85%B3%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB/"/>
    <url>/2021/09/02/%E7%9B%B8%E5%85%B3%E6%B6%88%E6%81%AF%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>本文介绍的是相关消息攻击。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ycdxsb.cn/2decc525.html">https://ycdxsb.cn/2decc525.html</a></p></li><li><p><a href="https://xz.aliyun.com/t/6813#toc-2">https://xz.aliyun.com/t/6813#toc-2</a></p></li><li><p>《Low-Exponent RSA with Related Messages 》by Coppersmith, Franklin, Patarin and Reiter</p></li><li><p>《Solving Systems of Modular Equations in OneVariable: How Many RSA-Encrypted MessagesDoes Eve Need to Know?》by Alexander May, Maike Ritzenhofent</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li><p>RSA原理</p></li><li><p>lattice和LLL算法</p></li><li><p>多项式代数</p><h2 id="使用工具-库"><a href="#使用工具-库" class="headerlink" title="使用工具/库"></a>使用工具/库</h2><ul><li>sagemath</li><li>python的gmpy2库</li></ul></li></ul><h1 id="线性相关消息"><a href="#线性相关消息" class="headerlink" title="线性相关消息"></a>线性相关消息</h1></li></ul><h2 id="k-2（k为消息数）"><a href="#k-2（k为消息数）" class="headerlink" title="k=2（k为消息数）"></a>k=2（k为消息数）</h2><p>假设两则相关消息满足：</p><script type="math/tex; mode=display">(a_1m+b_1)^e \equiv c_1\ (mod\ n)\\(a_2m+b_2)^e \equiv c_2\ (mod\ n)</script><p>那么模多项式$(a_1m+b_1)^e-c_1\ (mod\ n)$和$(a_2m+b_2)^e-c_2\ (mod\ n)$一般来说会存在一个形如<script type="math/tex">m-m_0</script>的$gcd$，对这两个多项式在模n下求$gcd$，得到$m-m_0$，$m_0$即为我们要求的$m$。对于这两个多项式$gcd$不为线性函数的情况，本文暂不讨论。</p><h2 id="k-gt-2（k为消息数"><a href="#k-gt-2（k为消息数" class="headerlink" title="k&gt;2（k为消息数)"></a>k&gt;2（k为消息数)</h2><p>假设k则消息之间满足多项式：</p><script type="math/tex; mode=display">p(x_1,x_2,...,x_k)=0</script><p>并且有：</p><script type="math/tex; mode=display">p_1(x_1)=x_1^e-c_1=0\ (mod\ n)</script><script type="math/tex; mode=display">p_2(x_2)=x_2^e-c_2=0\ (mod\ n)</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">p_i(x_i)=x_i^e-c_i=0\ (mod\ n)</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">p_k(x_k)=x_k^e-c_k=0\ (mod\ n)</script><p>然后我们求出它们的Groebner基，即可求</p><p>得$x_i=m_i$，对于这k个式子，可求出k个解，这k个解即为我们要找的解。</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>通过我们的的操作可以看出，其实这里并不局限于线性相关，在这里多项式相关都是可以的，所以此处改为“多项式相关消息”可能更准确。</p><h1 id="Hastad广播攻击"><a href="#Hastad广播攻击" class="headerlink" title="Hastad广播攻击"></a>Hastad广播攻击</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前面介绍的相关消息攻击模数都是一样的，Hastad广播攻击中则对模数不同的攻击进行了讨论。</p><h2 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h2><p>对于使用不同的但是互素的模数n，相同的加密指数e，加密e个明文得到e个密文：</p><script type="math/tex; mode=display">(a_ix+b_i)^e \equiv c_i\ (mod\ n_i)\ ,\ i=1,2,...,e</script><p>由于模数互素，我们通过多项式的中国剩余定理，可以得到$P(x)\equiv 0\ (mod\ M)，M=\prod_{i=1}^en_i$，$P(x)$存在唯一解，并且这个解满足LLL算法的条件，所以我们可以据此求出解，得到x，恢复明文。</p><h1 id="SMUPE问题"><a href="#SMUPE问题" class="headerlink" title="SMUPE问题"></a>SMUPE问题</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>无论是前面的线性相关消息攻击（多项式相关消息攻击），还是Hastad广播攻击，我们尽管使用了不同的模数n，但我们使用的指数e都是一样的。在SMUPE问题（systems of modular univariate polynomial equations）中，我们使用的加密指数e也可以不同，如：</p><script type="math/tex; mode=display">(a_ix+b_i)^{e_i}\equiv c_i\ (mod\ n_i)\ ,\ i=1,2,...,k\\记f_i(x)=(a_ix+b_i)^{e_i}</script><p>此时由于模数不同，我们无法直接使用中国剩余定理，因此需要构造同阶的多项式。</p><p>为了构造这样的多项式，Hastad采取了两边同时乘$(a_ix+b_i)^{\delta-\delta_i}$的方法来统一阶数，其中$\delta$为最高次数。</p><p>而在论文《Solving Systems of Modular Equations in OneVariable: How Many RSA-Encrypted MessagesDoes Eve Need to Know?》by Alexander May, Maike Ritzenhofent 中，他们提出了另外一种更有效的平衡阶数的方法，用阶数的最小公倍数来构造（在这里$\delta_i$的意义和$e_i$一样）：</p><script type="math/tex; mode=display">[f_i(x)]^{\delta/\delta_i}\equiv c_i^{\delta/\delta_i}\ (mod\ n_i)\ , \ i=1,2,...,k\ ,\ \delta=lcm(\delta_j,j=1,2,...,k)</script><p>这里的所有多项式都是首一的多项式（$monic\ polynomial$）.</p><p>此时可以用中国剩余定理解决，作者们证明了这种攻击能够成功的条件为（满足LLL算法的条件）：</p><script type="math/tex; mode=display">\sum_{i=1}^k1/\delta_i≥1</script><hr><p>本文对相关消息攻击的讨论大致就如上所述，本文为理论性学习文章，因此不涉及代码部分，解题方面还需移步CTF-Crypto-题目实践。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Crypto</category>
      
      <category>理论学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Love_DengFeng&#39;s Blog</title>
    <link href="/2021/08/30/Love_DengFeng&#39;s%20Blog/"/>
    <url>/2021/08/30/Love_DengFeng&#39;s%20Blog/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><hr><p><strong><em>2021年8月29日</em></strong>，我终于把自己很早之前的想法付诸实践了——搭建一个自己的博客站点，来记录自己的学习历程，同时分享一些个人的想法以及学习的内容来跟各位 $dalao$ 互相交流学习。<strong><em>8月30日</em></strong>，AK了 $DASCTF$ 八月挑战赛 $Crypto$ 部分后（本人很菜，是题目太简单了），大概熟悉了博客的管理运行发布删除等操作以及用 $markdown$ 写博客的方法后，写下这第一篇博客来开启我的学习记录路程。最近几个月的重心应该还是会放在 $CTF$ 的 $Crypto$ 方向上，提高自己的水平，期待自己能得到更大的提升。</p><script type="math/tex; mode=display">联系方式：</script><script type="math/tex; mode=display">QQ:1440416491</script><script type="math/tex; mode=display">E-mail:1440416491@qq.com</script><p>这是<a href="https://www.zhihu.com/people/deng-feng-10-87-48">我的知乎</a>，里面记录了一些数论的理论，dalao们不妨关注一波，<del>给我加一点关注量</del>说不定能学到一点点东西。</p><p>欢迎各路$dalao$交流学习！</p>]]></content>
    
    
    <categories>
      
      <category>introduction</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
